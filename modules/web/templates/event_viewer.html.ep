% layout 'default';
% title 'kdesrc-build status viewer';

<h1 class="title">kdesrc-build status</h1>

<div id="divBanner"></div>

<div class="content">
  <strong>Current status</strong>:
  <span id="divStatus" class="is-info">Build in progress</span>
  <button class="button is-warning" id="btnReset" disabled>Click to Reset</button>
</div>

<table class="table is-striped is-hoverable">
  <thead>
    <tr>
      <th>Module</th>
      <th>Update</th>
      <th>Setup buildsystem</th>
      <th>Build</th>
      <th>Test</th>
      <th>Install</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody id="tblResult">
  </tbody>
</table>

%# Mojolicious will move this into the <nav> where it belongs since I
%# assigned 'navbar-brand-extra' into the template in layouts/default.html.ep
% content 'navbar-brand-extra' => begin
  <div class="navbar-item">
    <div class="field">
      <label for="update_progress_bar">Update progress:</label>
      <progress class="progress" id="update_progress_bar" max="100"></progress>
    </div>
  </div>

  <div class="navbar-item">
    <div class="field">
      <label for="build_progress_bar">Build progress:</label>
      <progress class="progress" id="build_progress_bar" max="100"></progress>
    </div>
  </div>
% end

<textarea id="logEntries" cols="80" rows="50">
</textarea>

<script defer>
let addRow = (moduleName) => {
    if (!moduleName) {
        console.trace("Stupidity afoot");
        return;
    }

    let eventTable = lkup('tblResult');
    let newRow = document.createElement('tr');
    newRow.id = 'row_' + moduleName;

    const phases = [
        'update', 'buildsystem', 'build', 'test', 'install',
        'notes' // Not a real phase but gives us a cell for info
        ];

    let moduleNameCell = document.createElement('td');
    moduleNameCell.textContent = moduleName;
    newRow.appendChild(moduleNameCell);

    for (const phase of phases) {
      let phaseDoneCell = document.createElement('td');
      phaseDoneCell.id = phase + "Cell_" + moduleName;
      if (phase !== "notes") {
          phaseDoneCell.classList.add('is-info');
      }
      newRow.appendChild(phaseDoneCell);
    }

    eventTable.appendChild(newRow);
}

const divStatus = document.getElementById('divStatus');
let entriesDiv  = document.getElementById('logEntries');

const logEvent = (module, event) => {
    newText = `${module}: ${event}\n`;
    entriesDiv.value += newText;
}

let updates_complete = 0;
let builds_complete  = 0;
let BUILD_PLAN = null;

let handleEvent = (ev) => {

    if (ev.event === "build_plan") {
        const text = "Working on " + ev.build_plan.length + " modules";
        BUILD_PLAN = ev.build_plan;

        let num_updates = 0;
        let num_builds  = 0;
        ev.build_plan.forEach((module_plan) => {
            addRow(module_plan.name);

            // The new row comes with every cell made already-done. Undo
            // for cells that are in the plan
            module_plan.phases.forEach((module_phase) => {
                let cell = lkup(module_phase + "Cell_" + module_plan.name);
                cell.classList.add('pending');
                cell.classList.remove('is-info');
            });

            num_updates += module_plan.phases.includes("update") ? 1 : 0;
            // Any non-update phase is lumped into "build" for this U/I
            num_builds  += (module_plan.phases.length >= 2) ? 1 : 0;
        });

        lkup('update_progress_bar').setAttribute('max', num_updates);
        lkup('build_progress_bar' ).setAttribute('max', num_builds );
    }
    else if (ev.event === "build_done") {
        const resetLink = '<%= url_for q(reset) %>';
        const homeLink = '<%= url_for q(index) %>';

        divStatus.textContent = 'Build complete';
        divStatus.classList.add('is-success'); // TODO: Ensure failed builds show failed here
        divStatus.classList.remove('is-info');

        const btnReset = document.getElementById('btnReset');
        btnReset.removeAttribute('disabled');
        btnReset.addEventListener('click', (ev) => {
            fetch(resetLink, {
                method: 'POST'
            })
            .then(resp => {
                if (!resp.ok) {
                    throw new Error("Invalid response resetting kdesrc-build");
                }
                return resp.json();
            })
            .then(last_result => {
                console.log("Last result was ", last_result.last_result)
                document.location.assign (homeLink);
            })
            .catch(error => console.error(error));
        }, { passive: false });
    }
    else if (ev.event === "phase_started") {
        const phase  = ev.phase_started.phase;
        const module = ev.phase_started.module;

        let row = lkup("row_" + module);
        if (!row) {
            console.error(`Row for ${module} does not already exist somehow!`);
            return;
        }

        let cell = lkup(phase + "Cell_" + module);
        if (!cell) {
            console.error(`Could not find cell for ${module} starting phase ${phase}!`);
            return;
        }

        cell.classList.add('working');
        cell.classList.add('notification');
        cell.classList.add('is-loading');
        cell.classList.add('is-primary');
        cell.classList.remove('pending');

        cell.textContent = '';
    }
    else if (ev.event === "phase_progress") {
        const phase  = ev.phase_progress.phase;
        const module = ev.phase_progress.module;
        const progressAry = ev.phase_progress.progress;

        let cell = lkup(phase + "Cell_" + module);
        if (!cell) {
            return;
        }

        // progressAry will be a float between 0 and 1
        cell.textContent = (100.0 * progressAry).toFixed(1);
    }
    else if (ev.event === "phase_completed") {
        const phase  = ev.phase_completed.phase;
        const module = ev.phase_completed.module;

        let cell = lkup(phase + "Cell_" + module);
        if (!cell) {
            console.log(`${module} ${phase} is complete but we have no U/I to indicate this`);
            return;
        }

        if (phase === "update") {
            updates_complete++;
        }

        cell.className = 'done';
        cell.classList.remove('is-loading');
        cell.classList.remove('notification');
        cell.classList.add('is-light');

        if (['success', 'error'].
            includes(ev.phase_completed.result))
        {
            cell.classList.add('is-' + ev.phase_completed.result);
            cell.classList.add(ev.phase_completed.result);
        } else {
            // Might happen with stop-on-failure for instance? Show that progress
            // won't be made but it didn't fail or succeed either.
            cell.classList.add('is-warning');
        }

        if (ev.phase_completed.error_log) {
            const logUrl = ev.phase_completed.error_log;
            const notesCell = lkup('notesCell_' + module);
            notesCell.innerHTML = `<a target='_blank' href='${logUrl}'>${ev.phase_completed.result}</a>`;
            logEvent(module, 'Failed to ' + phase);
        } else {
            cell.innerHTML = ev.phase_completed.result;
            cell.textContent = ev.phase_completed.result === "success"
                ? '👍' : ev.phase_completed.result === "error"
                ? '☹️'  : '🤷';
        }

        // If all successful for the module, remove the row
        const moduleRow = lkup("row_" + module);
        if (moduleRow.querySelectorAll('td.pending').length == 0) {
            if (moduleRow.querySelectorAll('td.done').length >= 2) {
                // Only modules with 2 or more phases contribute to this
                // progress bar.
                builds_complete++;
            }
            console.log(`Module ${module} seems to be all done`);
            if (moduleRow) {
                // Need to keep the row for status updating, I think?
                // moduleRow.remove(); // "Experimental" ChildNode iface
            }
        }

        lkup('update_progress_bar').setAttribute('value', updates_complete);
        lkup('build_progress_bar' ).setAttribute('value', builds_complete );
    }
    else if (ev.event === "log_entries") {
        const phase  = ev.log_entries.phase;
        const module = ev.log_entries.module;
        const entries = ev.log_entries.entries;

        for(const entry of entries) {
            logEvent(module, entry);
        }
    }
    else {
        console.error("Unhandled event ", ev.event);
        console.error(ev);
    }
}

let ws = new WebSocket('<%= url_for("events")->to_abs %>');

ws.onmessage = (msg_event) => {
    const events = JSON.parse(msg_event.data);

    if (!events) {
        console.log(`Received invalid JSON object in WebSocket handler ${msg_event}`);
        return;
    }

    // event should be an array of JSON objects
    for (const e of events) {
        handleEvent(e);
    }
}
</script>
