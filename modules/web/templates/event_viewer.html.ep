% layout 'default';
% title 'kdesrc-build status viewer';

<h1 class="title">kdesrc-build status</h1>

<div id="divBanner"></div>

<div class="content">
  <strong>Current status</strong>:
  <span id="divStatus" class="is-info">Build in progress</span>
  <button class="button is-warning" id="btnReset" disabled>Click to Reset</button>
</div>

<table class="table is-striped is-hoverable">
  <thead>
    <tr><th>Module</th><th>Update</th><th>Build / Install</th></tr>
  </thead>
  <tbody id="tblResult">
  </tbody>
</table>

<!-- Horizontal container for content
     https://bulma.io/documentation/layout/level/
-->
<div class="level">
  <div class="level-left">
    <div class="level-item">
      <label for="update_progress_bar">Update progress:</label>
      <progress class="progress" id="update_progress_bar" max="100"></progress> <br/>
    </div>

    <div class="level-item">
      <label for="build_progress_bar">Build progress:</label>
      <progress class="progress" id="build_progress_bar" max="100"></progress>
    </div>
  </div>

  <div class="level-right">
  </div>
</div>

<textarea id="logEntries" cols="80" rows="50">
</textarea>

<script defer>
let addRow = (moduleName) => {
    if (!moduleName) {
        console.trace("Stupidity afoot");
        return;
    }

    let eventTable = lkup('tblResult');
    let newRow = document.createElement('tr');
    let moduleNameCell = document.createElement('td');
    let updateDoneCell = document.createElement('td');
    let buildDoneCell  = document.createElement('td');

    newRow.id = 'row_' + moduleName;
    moduleNameCell.textContent = moduleName;
    updateDoneCell.id = 'updateCell_' + moduleName;
    updateDoneCell.classList.add('pending');
    buildDoneCell.id  = 'buildCell_'  + moduleName;
    buildDoneCell.classList.add('pending');

    newRow.appendChild(moduleNameCell);
    newRow.appendChild(updateDoneCell);
    newRow.appendChild(buildDoneCell);
    eventTable.appendChild(newRow);
}

const divStatus = document.getElementById('divStatus');
let entriesDiv  = document.getElementById('logEntries');

const logEvent = (module, event) => {
    newText = `${module}: ${event}\n`;
    entriesDiv.value += newText;
}

let updates_complete = 0;
let builds_complete  = 0;
let handleEvent = (ev) => {

    if (ev.event === "build_plan") {
        const text = "Working on " + ev.build_plan.length + " modules";

        let num_updates = 0;
        let num_builds  = 0;
        ev.build_plan.forEach((module_plan) => {
            module_plan.phases.forEach((phase) => {
                num_updates += phase === "update" ? 1 : 0;
                num_builds  += phase === "build"  ? 1 : 0;
            });
        });

        lkup('update_progress_bar').setAttribute('max', num_updates);
        lkup('build_progress_bar' ).setAttribute('max', num_builds );
    }
    else if (ev.event === "build_done") {
        const resetLink = '<%= url_for q(reset) %>';
        const homeLink = '<%= url_for q(index) %>';

        divStatus.textContent = 'Build complete';
        divStatus.classList.add('is-success'); // TODO: Ensure failed builds show failed here
        divStatus.classList.remove('is-info');

        const btnReset = document.getElementById('btnReset');
        btnReset.removeAttribute('disabled');
        btnReset.addEventListener('click', (ev) => {
            fetch(resetLink, {
                method: 'POST'
            })
            .then(resp => {
                if (!resp.ok) {
                    throw new Error("Invalid response resetting kdesrc-build");
                }
                return resp.json();
            })
            .then(last_result => {
                console.log("Last result was ", last_result.last_result)
                document.location.assign (homeLink);
            })
            .catch(error => console.error(error));
        }, { passive: false });
    }
    else if (ev.event === "phase_started") {
        const phase  = ev.phase_started.phase;
        const module = ev.phase_started.module;

        let row = lkup("row_" + module);
        if (!row) {
            addRow(module);
        }

        let cell = lkup(phase + "Cell_" + module);
        if (!cell) {
            return;
        }

        cell.classList.add('working');
        cell.classList.add('is-loading');
        cell.classList.add('is-primary');

        cell.textContent = 'Working...';
    }
    else if (ev.event === "phase_progress") {
        const phase  = ev.phase_progress.phase;
        const module = ev.phase_progress.module;
        const progressAry = ev.phase_progress.progress;

        let cell = lkup(phase + "Cell_" + module);
        if (!cell) {
            return;
        }

        // progressAry will be a float between 0 and 1
        cell.textContent = (100.0 * progressAry).toFixed(1);
    }
    else if (ev.event === "phase_completed") {
        const phase  = ev.phase_completed.phase;
        const module = ev.phase_completed.module;

        let cell = lkup(phase + "Cell_" + module);
        if (!cell) {
            console.log(`${module} ${phase} is complete but we have no U/I to indicate this`);
            return;
        }

        if (phase === "update") {
            updates_complete++;
        } else {
            builds_complete++;
        }

        lkup('update_progress_bar').setAttribute('value', updates_complete);
        lkup('build_progress_bar' ).setAttribute('value', builds_complete );

        cell.className = 'done';
        cell.classList.remove('is-loading');
        cell.classList.add('is-light');

        if (['success', 'error'].
            includes(ev.phase_completed.result))
        {
            cell.classList.add('is-' + ev.phase_completed.result);
            cell.classList.add(ev.phase_completed.result);
        }

        if (ev.phase_completed.error_log) {
            const logUrl = ev.phase_completed.error_log;
            cell.innerHTML = `<a target='_blank' href='${logUrl}'>${ev.phase_completed.result}</a>`;
            logEvent(module, 'Failed to ' + phase);
        } else if (phase !== 'update') {
            // If all successful for the module, remove the row
            const updateResult = lkup('updateCell_' + module);
            if (updateResult && updateResult.classList.contains('success')) {
                const moduleRow = lkup('row_' + module);
                if (moduleRow) {
                    // This was clashing with another part of the script causing the row
                    // to be immediately regenerated... fix it when you figure it out :)
                    // moduleRow.remove(); // "Experimental" ChildNode iface
                }
                logEvent(module, 'Success');
            }
        } else {
            cell.innerHTML = ev.phase_completed.result;
        }
    }
    else if (ev.event === "log_entries") {
        const phase  = ev.log_entries.phase;
        const module = ev.log_entries.module;
        const entries = ev.log_entries.entries;

        for(const entry of entries) {
            logEvent(module, entry);
        }
    }
    else {
        console.error("Unhandled event ", ev.event);
        console.error(ev);
    }
}

let ws = new WebSocket('<%= url_for("events")->to_abs %>');

ws.onmessage = (msg_event) => {
    const events = JSON.parse(msg_event.data);

    if (!events) {
        console.log(`Received invalid JSON object in WebSocket handler ${msg_event}`);
        return;
    }

    // event should be an array of JSON objects
    for (const e of events) {
        handleEvent(e);
    }
}
</script>
