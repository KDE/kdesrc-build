#!/usr/bin/env perl

# Script to handle building KDE from source code.  All of the configuration is
# stored in the file ./kdesrc-buildrc (or ~/.kdesrc-buildrc, if that's not
# present).
#
# Please also see the documentation that should be included with this program,
# in the doc/ directory.
#
# Home page: https://kdesrc-build.kde.org/
#
# Copyright © 2003 - 2020 Michael Pyne. <mpyne@kde.org>
# Copyright © 2018 - 2020 Johan Ouwerkerk <jm.ouwerkerk@gmail.com>
# Copyright © 2005, 2006, 2008 - 2011 David Faure <faure@kde.org>
# Copyright © 2005 Thiago Macieira <thiago@kde.org>
# Copyright © 2006 Stephan Kulow <coolo@kde.org>
# Copyright © 2006, 2008 Dirk Mueller <mueller@kde.org>
# ... and possibly others. Check the git source repository for specifics.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

# Adding an option? Grep for 'defaultGlobalOptions' in ksb::BuildContext --mpyne

use v5.22; # Require Perl 5.22
use warnings;

# On many container-based distros, even FindBin is missing to conserve space.
# But we can use File::Spec to do nearly the same.
my $RealBin;
my $modPath;

# The File::Spec calls have to run when parsing (i.e. in BEGIN) to make the
# 'use lib' below work (which itself implicitly uses BEGIN { })
BEGIN {
    use File::Spec;

    # resolve symlinks
    my $scriptPath = $0;
    for (1..16) {
        last unless -l $scriptPath;
        $scriptPath = readlink $scriptPath;
    }
    die "Too many symlinks followed looking for script" if -l $scriptPath;

    my ($volume, $directories, $script) = File::Spec->splitpath($scriptPath);

    $RealBin = File::Spec->catpath($volume, $directories, '');
    die "Couldn't find base directory!" unless $RealBin;

    # Use modules in git repo if running from git dir, otherwise assume
    # system install
    $modPath = File::Spec->rel2abs('modules', $RealBin);
    $modPath = ($RealBin =~ s,/bin/?$,/share/kdesrc-build/modules,r)
        unless -d $modPath;

    die "Couldn't find modules for kdesrc-build!" unless $modPath;
}

use lib "$modPath"; # Make ksb:: modules available

sub dumpError
{
    my $err = shift;
    open my $fh, '>>', "error-$$.log" or return;
    my $time = localtime;
    say $fh $time;
    say $fh $@;
}

# When running in a limited environment, we might not be able to load
# our modules although we can find them. In this case we should help user
# by setting up system dependencies.
eval {
    if (grep { $_ eq '--initial-setup' } @ARGV) {
        require ksb::FirstRun;
        require ksb::Debug;
        ksb::Debug::setColorfulOutput(1);
        exit ksb::FirstRun::setupUserSystem(File::Spec->rel2abs($RealBin));
    }
};

if ($@) {
    dumpError($@);
    say STDERR <<DONE;
* Unable to even load the simplistic initial setup support for some reason??

More detail might be available in error-$$.log

You could:
 File a bug https://bugs.kde.org/enter_bug.cgi?product=kdesrc-build
 Ask for help on Freenode IRC in the #kde channel
DONE
    exit 1;
}

# This section avoids Perl compile errors when needed core modules are not
# installed. This permits us to make it far enough along at runtime to put out
# a proper error message so that the rest of our Perl code can be more
# 'normal'.
#
# After the error check below, we will manually import the package symbols.
#
# For more info run 'perldoc -f use' and see it's explanation of how it is
# implemented in terms of require Foo / Foo->import() in a BEGIN block.
eval {
    require Carp;
    require ksb::Debug;
    require ksb::Util;
    require ksb::Version;
    require ksb::Application;
    require ksb::BuildException;
    require ksb::UserInterface::TTY;
    require web::BackendServer;

    require Mojo::IOLoop;
    require Mojo::Server::Daemon;

    require Storable;
};

if ($@) {
    my $err = $@;
    dumpError($err);
    say STDERR <<DONE;
Couldn't load the base platform for kdesrc-build!

    $err
DONE

    if (! -e "kdesrc-buildrc" && ! -e "$ENV{HOME}/.kdesrc-buildrc") {
        say STDERR <<DONE;
It appears you've not run kdesrc-build before.

Please run "kdesrc-build --initial-setup" and kdesrc-build will guide you
through setting up required dependencies and environment setup.
DONE
    }
    exit 1;
}

# Now that we know that our 'require' statements above did not cause any
# problems, we can import their symbols into the global symbol table.
ksb::Debug->import();
ksb::Util->import();
ksb::BuildException->import();
ksb::Version->import(qw(scriptVersion));
ksb::Application->import();
ksb::UserInterface::TTY->import();
web::BackendServer->import();

Mojo::IOLoop->import();
Mojo::Server::Daemon->import();

Storable->import(qw(dclone));

# Make Perl 'plain die' exceptions use Carp::confess instead of their core
# support. This is not supported by the Perl 5 authors but assuming it works
# will be better than the alternative backtrace we get (which is to say, none)
$SIG{__DIE__} = \&Carp::confess;

ksb::Version->path($RealBin);

# Rather than running an interactive build, launches a web server that can be
# interacted with by and outside user interface, printing the URL to the server
# on stdout and then remaining in the foreground until killed.
sub launchBackend
{
    # Manually setup the daemon so that we can figure out what port it
    # ends up on.
    my $daemon = Mojo::Server::Daemon->new(
        app    => web::BackendServer->new,
        listen => ['http://localhost'],
        silent => !exists $ENV{KDESRC_BUILD_DEBUG},
    );

    $daemon->start; # Grabs the socket to listen on

    my $port = $daemon->ports->[0] or do {
        say STDERR "Can't autodetect which TCP port was assigned!";
        exit 1;
    };

    say "http://localhost:$port";

    Mojo::IOLoop->start
        unless Mojo::IOLoop->is_running;

    exit 0;
}

# Script starts.

# Drop here if we're in backend-only mode.
launchBackend()
    if (scalar @ARGV == 1 && $ARGV[0] eq '--backend');

our @atexit_subs;

END {
    # Basically used to call the finish() handler but only when appropriate.
    foreach my $sub (@atexit_subs) {
        &$sub();
    }
}

# TODO: Need to split up option reading here to exit early for options
# that need the rc-file read (--dependency-list, --query, etc.) and don't involve
# the web server.

# Use some exception handling to avoid ucky error messages
eval
{
    my $optsAndSelectors = ksb::Application::readCommandLineOptionsAndSelectors(@ARGV);
    ksb::Application::_handleEarlyOptions($optsAndSelectors); # may exit!

    # Try to read up through the rc-file to abort before we launch the backend
    # if the file is malformed. If the rc-file is malformed then the exception
    # that results is better thrown before we start the backend.
    {
        if (grep { $_ eq 'query' } keys %{$optsAndSelectors->{options}->{global}}) {
            # This is quite heavyweight but necessary for query for now.
            # TODO: Save items as persistent options for easy lookup later?
            my $app = ksb::Application::newFromCmdline(@ARGV);

            # may exit!
            $app->handleQueryOptions();
        } else {
            my $app = ksb::Application->new;

            # Read rc-file to force error checking
            $app->createBuildContextWithoutMetadata(
                $app->context(),
                dclone($optsAndSelectors));
        }
    }

    my $app = web::BackendServer->new({
            config => $optsAndSelectors
        });
    my $ui  = ksb::UserInterface::TTY->new($app);

    push @atexit_subs, sub { $app->ksb->finish(99) };

    # TODO: Reimplement --print-modules, --query modes, which wouldn't go through ->start
    my $result = $ui->start();

    @atexit_subs = (); # Clear exit handlers

    # env driver is just the ~/.config/kde-env-*.sh, session driver is that + ~/.xsession
    # TODO: Move to Backend or UserInterface as appropriate.
    my $ctx = $app->context;
    if ($ctx->getOption('install-environment-driver') ||
        $ctx->getOption('install-session-driver'))
    {
        ksb::Application::_installCustomSessionDriver($ctx);
    }

    # Setup global kde: shorthand options. Username and user email setup is
    # done per repository.
    ksb::Updater::Git::verifyGitConfig($app->context());

    # Exits the script
    exit $result;
};

if (my $err = $@)
{
    if (had_an_exception()) {
        say "kdesrc-build encountered an exceptional error condition:";
        say " ========";
        say "    $err";
        say " ========";
        say "\tCan't continue, so stopping now.";

        say "\nPlease submit a bug against kdesrc-build on https://bugs.kde.org/"
            if ($err->{exception_type} eq 'Internal');
    }
    else {
        # An exception was raised, but not one that kdesrc-build generated
        say "Encountered an error in the execution of the script.";
        say "The error reported was $err";
        say "Please submit a bug against kdesrc-build on https://bugs.kde.org/";
    }

    exit 99;
}

# vim: set et sw=4 ts=4:
